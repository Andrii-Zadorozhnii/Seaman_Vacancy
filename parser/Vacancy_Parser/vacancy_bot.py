import asyncio
import logging
import random
import sys
import os
import sqlite3
from datetime import datetime, timedelta, time
from typing import Optional
from dotenv import load_dotenv

from aiogram import Bot, Dispatcher, types
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder, ReplyKeyboardBuilder

load_dotenv()

TELEGRAM_TOKEN = os.getenv("BOT_TOKEN_VACANCY")
GROUP_ID_VACANCY = os.getenv("GROUP_ID_VACANCY")
ADMIN_IDS_VACANCY = (
    [int(id_) for id_ in os.getenv("ADMIN_IDS_VACANCY").split(",")]
    if os.getenv("ADMIN_IDS_VACANCY")
    else []
)
# Import your existing parser
from Vacancy_Parser import VacancyParser

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("vacancy_bot.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)


class Database:
    """Database context manager for SQLite operations"""

    def __init__(self, db_name="crewing.db"):
        """Initialize the Database context manager.

        Sets the database name for SQLite operations.
        """
        self.db_name = db_name

    def __enter__(self):
        self.conn = sqlite3.connect(self.db_name)
        self.conn.row_factory = sqlite3.Row
        return self.conn.cursor()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.conn.rollback()
            logger.error(f"Database error: {exc_val}")
        else:
            self.conn.commit()
        self.conn.close()


async def on_startup(bot: Bot):
    """Function to run on bot startup"""
    await bot.delete_webhook()
    logger.info("Bot started successfully")


class VacancyBot:
    def __init__(self, token: str, group_id: str, admin_ids: list[int]):
        self.bot = Bot(
            token=token, default=DefaultBotProperties(parse_mode=ParseMode.HTML)
        )
        self.dp = Dispatcher()
        self._parsing_delay = 20  # minutes between checks
        self.group_id = group_id
        self.admin_ids = admin_ids
        self.parser = VacancyParser()
        self.parsing_active = False
        self.parsing_task = None
        self.request_delay = random.randint(3, 6)  # seconds between requests

        # Register handlers
        self.register_handlers()

    @property
    def parsing_delay(self) -> int:
        """Get parsing delay in minutes"""
        return self._parsing_delay

    @parsing_delay.setter
    def parsing_delay(self, value: int):
        """Set parsing delay (minimum 5 minutes)"""
        self._parsing_delay = max(5, value)

    def register_handlers(self):
        """Register all command handlers"""
        self.dp.message(Command("start"))(self.start_command)
        self.dp.message(Command("help"))(self.help_command)
        self.dp.message(Command("admin_parse"))(self.admin_parse)
        self.dp.message(Command("broadcast"))(self.broadcast_command)
        self.dp.message(Command("toggle_parsing"))(self.toggle_parsing)
        self.dp.message(Command("settings"))(self.settings_command)

        # Button handlers
        self.dp.callback_query(lambda c: c.data == "last_vacancies")(
            self.last_vacancies_button
        )
        self.dp.callback_query(lambda c: c.data == "parse_vacancies")(
            self.parse_vacancies_button
        )
        self.dp.callback_query(lambda c: c.data == "show_stats")(self.stats_button)
        self.dp.callback_query(lambda c: c.data == "toggle_parsing")(
            self.toggle_parsing_button
        )
        self.dp.callback_query(lambda c: c.data.startswith("vacancy_"))(
            self.vacancy_callback
        )
        self.dp.callback_query(
            lambda c: c.data in ["increase_delay", "decrease_delay", "cancel_settings"]
        )(self.handle_settings_callback)

        # Text message handlers for buttons
        self.dp.message(lambda msg: msg.text == "üîç –ü–æ—Å–ª–µ–¥–Ω–∏–µ –≤–∞–∫–∞–Ω—Å–∏–∏")(
            self.last_vacancies_button
        )
        self.dp.message(lambda msg: msg.text == "üîÑ –ù–∞–π—Ç–∏ –Ω–æ–≤—ã–µ –≤–∞–∫–∞–Ω—Å–∏–∏")(
            self.parse_vacancies_button
        )
        self.dp.message(lambda msg: msg.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")(self.stats_button)
        self.dp.message(lambda msg: msg.text == "‚èØÔ∏è –ê–≤—Ç–æ–ø–æ–∏—Å–∫")(
            self.toggle_parsing_button
        )
        self.dp.message(lambda msg: msg.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞")(
            self.settings_command
        )
        self.dp.message(lambda msg: msg.text == "‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∏—Å–∫")(
            self.stop_parsing_button
        )
        self.dp.message(lambda msg: msg.text == "üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞")(
            self.restart_bot
        )

    async def create_main_keyboard(self) -> ReplyKeyboardMarkup:
        """Create main reply keyboard with buttons"""
        builder = ReplyKeyboardBuilder()
        buttons = [
            "üîç –ü–æ—Å–ª–µ–¥–Ω–∏–µ –≤–∞–∫–∞–Ω—Å–∏–∏",
            "üîÑ –ù–∞–π—Ç–∏ –Ω–æ–≤—ã–µ –≤–∞–∫–∞–Ω—Å–∏–∏",
            "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
            "‚èØÔ∏è –ê–≤—Ç–æ–ø–æ–∏—Å–∫",
            "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞",
            "‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∏—Å–∫",
            "üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞",
        ]
        for button in buttons:
            builder.add(KeyboardButton(text=button))
        builder.adjust(2, 2)
        return builder.as_markup(resize_keyboard=True)

    async def start_command(self, message: types.Message):
        """Handler for /start command"""
        if message.chat.type == "private":
            keyboard = await self.create_main_keyboard()
            await message.answer(
                "üõ≥Ô∏è <b>Maritime Vacancy Bot</b>\n\n"
                "I can fetch and post maritime job vacancies\n\n"
                "Use the buttons below to interact with the bot:",
                reply_markup=keyboard,
            )

    async def help_command(self, message: types.Message):
        """Handler for /help command"""
        keyboard = await self.create_main_keyboard()
        help_text = (
            "üîç <b>How to use this bot:</b>\n\n"
            "üîç <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –≤–∞–∫–∞–Ω—Å–∏–∏</b> - Show 5 most recent vacancies\n"
            "üîÑ <b>–ù–∞–π—Ç–∏ –Ω–æ–≤—ã–µ –≤–∞–∫–∞–Ω—Å–∏–∏</b> - Search for new vacancies\n"
            "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b> - Show database statistics\n"
            "‚èØÔ∏è <b>–ê–≤—Ç–æ–ø–æ–∏—Å–∫</b> - Toggle automatic parsing (admin only)\n"
            "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞</b> - Adjust parsing settings (admin only)\n"
            "‚èπ <b>–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∏—Å–∫</b> - Stop automatic parsing (admin only)\n"
            "üîÑ <b>–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞</b> - Restart the bot (admin only)\n\n"
            "You can click on any vacancy to see full details!"
        )
        await message.answer(help_text, reply_markup=keyboard)

    async def start_auto_parsing(self):
        """Main automatic parsing loop"""
        if self.parsing_active:
            return

        self.parsing_active = True
        logger.info(f"Automatic parsing started (delay: {self.parsing_delay} minutes)")

        while self.parsing_active:
            last_id = self.parser.get_last_vacancy_id()
            found = 0
            not_found_count = 0
            current_id = last_id + 1

            # Search phase
            while not_found_count < 5 and self.parsing_active:
                if self.parser.process_vacancy(current_id):
                    found += 1
                    not_found_count = 0
                    await self.post_vacancy(current_id)
                    await asyncio.sleep(self.request_delay)
                else:
                    not_found_count += 1
                current_id += 1

            # Results processing
            if found > 0:
                logger.info(f"Found {found} new vacancies in this iteration")
            else:
                logger.info(
                    f"No new vacancies found. Sleeping for {self.parsing_delay} minutes"
                )

            # Wait for next check
            if self.parsing_active:
                await asyncio.sleep(self.parsing_delay * 60)

    async def stop_auto_parsing(self):
        """Stop automatic parsing"""
        self.parsing_active = False
        logger.info("Automatic parsing stopped")

    async def post_vacancy(self, vacancy_id: int) -> bool:
        """Post vacancy to the group"""
        vacancy = self.get_vacancy(vacancy_id)
        if not vacancy:
            return False

        text = self.format_vacancy(vacancy)

        try:
            await self.bot.send_message(
                chat_id=self.group_id,
                text=text,
            )
            return True
        except Exception as e:
            logger.error(f"Error posting vacancy {vacancy_id}: {str(e)}")
            return False

    def get_vacancy(self, vacancy_id: int) -> Optional[dict]:
        """Get single vacancy from database"""
        try:
            with Database() as cursor:
                cursor.execute("SELECT * FROM vacancies WHERE id = ?", (vacancy_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except sqlite3.Error as e:
            logger.error(f"Database error: {str(e)}")
            return None

    def get_vacancies(self, limit: int = 5) -> list[dict]:
        """Get recent vacancies from database"""
        try:
            with Database() as cursor:
                cursor.execute(
                    "SELECT * FROM vacancies ORDER BY published DESC LIMIT ?", (limit,)
                )
                return [dict(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            logger.error(f"Database error: {str(e)}")
            return []

    def format_vacancy(self, vacancy: dict) -> str:
        """Format vacancy for display"""

        def safe_get(key, default="‚Äî"):
            value = vacancy.get(key)
            return str(value).strip() if value and str(value).strip() != "" else default

        lines = []
        lines.append(f"üìå <b>{safe_get('title')}</b>")
        lines.append("")

        # Main info
        lines.append(f"üóì <b>–î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏:</b> {safe_get('published')}")
        if safe_get("join_date") != "‚Äî":
            lines.append(f"üìÖ <b>–ù–∞—á–∞–ª–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞:</b> {safe_get('join_date')}")
        lines.append(f"üìè <b>–ö–æ–Ω—Ç—Ä–∞–∫—Ç:</b> {safe_get('contract_length')}")
        if safe_get("sailing_area") != "‚Äî":
            lines.append(f"üåç <b>–†–µ–≥–∏–æ–Ω –ø–ª–∞–≤–∞–Ω–∏—è:</b> {safe_get('sailing_area')}")
        lines.append("")

        # Vessel info
        if safe_get("vessel_type") != "‚Äî":
            lines.append(f"üö¢ <b>–¢–∏–ø —Å—É–¥–Ω–∞:</b> {safe_get('vessel_type')}")
        if safe_get("vessel_name") != "‚Äî":
            lines.append(f"üè∑ <b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {safe_get('vessel_name')}")
        if safe_get("built_year") != "‚Äî":
            lines.append(f"üìÖ <b>–ì–æ–¥ –ø–æ—Å—Ç—Ä–æ–π–∫–∏:</b> {safe_get('built_year')}")
        if safe_get("dwt") != "‚Äî":
            lines.append(f"‚öñÔ∏è <b>DWT:</b> {safe_get('dwt')}")
        lines.append("")

        # Requirements
        if safe_get("english_level") != "‚Äî":
            lines.append(f"üåê <b>–ê–Ω–≥–ª–∏–π—Å–∫–∏–π:</b> {safe_get('english_level')}")
        if safe_get("age_limit") != "‚Äî":
            lines.append(f"üéÇ <b>–í–æ–∑—Ä–∞—Å—Ç:</b> {safe_get('age_limit')}")
        if safe_get("experience") != "‚Äî":
            lines.append(f"üìÖ <b>–û–ø—ã—Ç –≤ –¥–æ–ª–∂–Ω–æ—Å—Ç–∏:</b> {safe_get('experience')}")
        lines.append("")

        # Salary
        if safe_get("salary") != "‚Äî":
            lines.append(f"üí∞ <b>–ó–∞—Ä–ø–ª–∞—Ç–∞:</b> {safe_get('salary')}")
            lines.append("")

        # Contacts
        if safe_get("phone") != "‚Äî":
            lines.append(f"üìû <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> {safe_get('phone')}")
        if safe_get("email") != "‚Äî":
            lines.append(f"üìß <b>Email:</b> {safe_get('email')}")
        if safe_get("manager") != "‚Äî":
            lines.append(f"üë§ <b>–ú–µ–Ω–µ–¥–∂–µ—Ä:</b> {safe_get('manager')}")
        lines.append("")

        # Company info
        if vacancy.get("company_id"):
            try:
                with Database() as cursor:
                    cursor.execute(
                        "SELECT * FROM companies WHERE id = ?", (vacancy["company_id"],)
                    )
                    company = cursor.fetchone()

                    if company:
                        company = dict(company)
                    if company.get("name"):
                        lines.append(f"üè¢ <b>–ö–æ–º–ø–∞–Ω–∏—è:</b> {company['name']}")
                    if company.get("country"):
                        lines.append(f"üåç <b>–°—Ç—Ä–∞–Ω–∞:</b> {company['country']}")
                    if company.get("email"):
                        lines.append(f"üìß <b>Email:</b> {company['email']}")
                    lines.append("")
            except sqlite3.Error as e:
                logger.error(f"Error fetching company info: {str(e)}")

        # Additional info
        if safe_get("additional_info") != "‚Äî":
            lines.append("üìù <b>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>")
            lines.append(safe_get("additional_info"))

        return "\n".join(lines)

    async def admin_parse(self, message: types.Message):
        """Admin-only parse command"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ Access denied")
            return

        try:
            parts = message.text.split()
            if len(parts) == 1:
                await message.answer("Usage: /admin_parse [start_id] [end_id]")
                return
            elif len(parts) == 2:
                start_id = int(parts[1])
                end_id = start_id + 10
            else:
                start_id = int(parts[1])
                end_id = int(parts[2])
        except ValueError:
            await message.answer("‚ö†Ô∏è Please provide valid numbers")
            return

        msg = await message.answer(
            f"‚è≥ Parsing vacancies from {start_id} to {end_id}..."
        )

        found = 0
        for vacancy_id in range(start_id, end_id + 1):
            if self.parser.process_vacancy(vacancy_id):
                found += 1
                await asyncio.sleep(1)

        await msg.edit_text(
            f"‚úÖ Found {found} new vacancies in range {start_id}-{end_id}!"
        )

    async def broadcast_command(self, message: types.Message):
        """Admin-only broadcast command"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ Access denied")
            return

        if not message.reply_to_message:
            await message.answer("Please reply to a message to broadcast")
            return

        try:
            with Database() as cursor:
                cursor.execute("SELECT DISTINCT user_id FROM user_actions")
                user_ids = [row[0] for row in cursor.fetchall()]
        except sqlite3.Error:
            user_ids = []

        if not user_ids:
            await message.answer("No users found to broadcast to")
            return

        success = 0
        failed = 0
        progress_msg = await message.answer(
            f"Broadcasting to {len(user_ids)} users... 0/{len(user_ids)}"
        )

        for i, user_id in enumerate(user_ids, 1):
            try:
                await message.reply_to_message.copy_to(user_id)
                success += 1
            except Exception:
                failed += 1

            if i % 10 == 0:
                await progress_msg.edit_text(
                    f"Broadcasting to {len(user_ids)} users... {i}/{len(user_ids)}\n"
                    f"‚úÖ Success: {success} | ‚ùå Failed: {failed}"
                )
            await asyncio.sleep(0.5)

        await progress_msg.edit_text(
            f"üì¢ Broadcast complete!\n" f"‚úÖ Success: {success} | ‚ùå Failed: {failed}"
        )

    async def toggle_parsing(self, message: types.Message):
        """Toggle automatic parsing (/toggle_parsing command)"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ Access denied")
            return

        if self.parsing_active:
            await self.stop_auto_parsing()
            await message.answer("‚èπ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        else:
            self.parsing_task = asyncio.create_task(self.start_auto_parsing())
            await message.answer("‚ñ∂Ô∏è –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∑–∞–ø—É—â–µ–Ω")

    async def toggle_parsing_button(self, update: types.Message | types.CallbackQuery):
        """Handler for toggle parsing button"""
        if isinstance(update, types.CallbackQuery):
            message = update.message
            user = update.from_user
            await update.answer()
        else:
            message = update
            user = update.from_user

        if not await self.is_admin(user.id):
            await message.answer("üö´ Access denied")
            return

        if self.parsing_active:
            await self.stop_auto_parsing()
            response = "‚èπ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        else:
            self.parsing_task = asyncio.create_task(self.start_auto_parsing())
            response = "‚ñ∂Ô∏è –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∑–∞–ø—É—â–µ–Ω"

        await message.answer(response)

    async def stop_parsing_button(self, message: types.Message):
        """Handler for stop parsing button"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ Access denied")
            return

        if self.parsing_active:
            await self.stop_auto_parsing()
            await message.answer("‚èπ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        else:
            await message.answer("–ê–≤—Ç–æ–ø–æ–∏—Å–∫ —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    async def settings_command(self, message: types.Message):
        """Handler for parsing settings command"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ Access denied")
            return

        builder = InlineKeyboardBuilder()
        builder.add(
            InlineKeyboardButton(
                text="‚ûï –£–≤–µ–ª–∏—á–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª", callback_data="increase_delay"
            ),
            InlineKeyboardButton(
                text="‚ûñ –£–º–µ–Ω—å—à–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª", callback_data="decrease_delay"
            ),
            InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_settings"),
        )
        builder.adjust(1, 1, 1)

        await message.answer(
            f"‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞</b>\n\n"
            f"–¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏: <b>{self.parsing_delay} –º–∏–Ω—É—Ç</b>\n"
            f"–ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏: <b>{self.request_delay} —Å–µ–∫—É–Ω–¥</b>",
            reply_markup=builder.as_markup(),
        )

    async def handle_settings_callback(self, callback: types.CallbackQuery):
        """Handle settings callback queries"""
        if not await self.is_admin(callback.from_user.id):
            await callback.answer("üö´ Access denied")
            return

        action = callback.data
        if action == "increase_delay":
            self.parsing_delay += 5
            text = f"–ò–Ω—Ç–µ—Ä–≤–∞–ª —É–≤–µ–ª–∏—á–µ–Ω –¥–æ {self.parsing_delay} –º–∏–Ω—É—Ç"
        elif action == "decrease_delay":
            if self.parsing_delay > 5:
                self.parsing_delay -= 5
                text = f"–ò–Ω—Ç–µ—Ä–≤–∞–ª —É–º–µ–Ω—å—à–µ–Ω –¥–æ {self.parsing_delay} –º–∏–Ω—É—Ç"
            else:
                text = "–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª - 5 –º–∏–Ω—É—Ç"
        else:  # cancel_settings
            await callback.message.delete()
            return

        await callback.answer(text)
        await self.settings_command(callback.message)

    async def last_vacancies_button(self, update: types.Message | types.CallbackQuery):
        """Show last vacancies"""
        if isinstance(update, types.CallbackQuery):
            message = update.message
            await update.answer()
        else:
            message = update

        vacancies = self.get_vacancies(limit=5)

        if not vacancies:
            await message.answer("No vacancies found in database")
            return

        builder = InlineKeyboardBuilder()
        for vac in vacancies:
            builder.row(
                InlineKeyboardButton(
                    text=f"{vac['title']} ({vac['published']})",
                    callback_data=f"vacancy_{vac['id']}",
                )
            )

        await message.answer(
            "üõ≥Ô∏è <b>Last 5 vacancies:</b>", reply_markup=builder.as_markup()
        )

    async def parse_vacancies_button(self, update: types.Message | types.CallbackQuery):
        """Handler for parse vacancies button"""
        if isinstance(update, types.CallbackQuery):
            message = update.message
            await update.answer()
        else:
            message = update

        msg = await message.answer("‚è≥ Searching for new vacancies...")

        last_id = self.parser.get_last_vacancy_id()

        found = 0
        not_found_count = 0
        current_id = last_id + 1

        while not_found_count < 5:
            if self.parser.process_vacancy(current_id):
                found += 1
                not_found_count = 0
                await self.post_vacancy(current_id)
                await asyncio.sleep(self.request_delay)
            else:
                not_found_count += 1

            current_id += 1

        await msg.edit_text(f"‚úÖ Found {found} new vacancies!")

    async def stats_button(self, update: types.Message | types.CallbackQuery):
        """Show statistics"""
        if isinstance(update, types.CallbackQuery):
            message = update.message
            await update.answer()
        else:
            message = update

        try:
            with Database() as cursor:
                # Get total vacancies count
                cursor.execute("SELECT COUNT(*) FROM vacancies")
                total_vacancies = cursor.fetchone()[0]

                # Get total companies count
                cursor.execute("SELECT COUNT(DISTINCT agency) FROM vacancies")
                total_companies = cursor.fetchone()[0]

                # Get recent vacancies count (last 7 days)
                one_week_ago = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")
                cursor.execute(
                    "SELECT COUNT(*) FROM vacancies WHERE published >= ?",
                    (one_week_ago,),
                )
                recent_vacancies = cursor.fetchone()[0]

                # Get top vessel types
                cursor.execute(
                    "SELECT vessel_type, COUNT(*) as count FROM vacancies "
                    "WHERE vessel_type IS NOT NULL AND vessel_type != '' "
                    "GROUP BY vessel_type ORDER BY count DESC LIMIT 5"
                )
                top_vessels = cursor.fetchall()

                vessels_text = (
                    "\n".join(f"  ‚ñ™Ô∏è {v[0]}: {v[1]}" for v in top_vessels)
                    if top_vessels
                    else "No data"
                )

                await message.answer(
                    "üìä <b>Database Statistics</b>\n\n"
                    f"üìÇ Total vacancies: <b>{total_vacancies}</b>\n"
                    f"üè¢ Total companies: <b>{total_companies}</b>\n"
                    f"üÜï Last 7 days: <b>{recent_vacancies}</b>\n\n"
                    "üö¢ <b>Top Vessel Types:</b>\n"
                    f"{vessels_text}"
                )

        except sqlite3.Error as e:
            logger.error(f"Database error in stats_button: {str(e)}")
            await message.answer(
                "‚ö†Ô∏è Error retrieving statistics. Please try again later."
            )

    async def vacancy_callback(self, callback: types.CallbackQuery):
        """Handle vacancy details callback"""
        vacancy_id = int(callback.data.split("_")[1])
        vacancy = self.get_vacancy(vacancy_id)

        if not vacancy:
            await callback.answer("Vacancy not found", show_alert=True)
            return

        text = self.format_vacancy(vacancy)

        builder = InlineKeyboardBuilder()
        if vacancy.get("phone") or vacancy.get("email"):
            if vacancy.get("phone"):
                phone = "".join(c for c in vacancy["phone"] if c.isdigit() or c == "+")
                builder.add(InlineKeyboardButton(text="üìû Call", url=f"tel:{phone}"))
            if vacancy.get("email"):
                builder.add(
                    InlineKeyboardButton(
                        text="üìß Email",
                        url=f"mailto:{vacancy['email']}?subject={vacancy.get('email_subject', 'Job Application')}",
                    )
                )

        await callback.message.answer(
            text, reply_markup=builder.as_markup() if builder.buttons else None
        )
        await callback.answer()

    async def is_admin(self, user_id: int) -> bool:
        """Check if user is admin"""
        return user_id in self.admin_ids

    async def restart_bot(self, message: types.Message):
        """Handler for bot restart"""
        if not await self.is_admin(message.from_user.id):
            await message.answer("üö´ –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º")
            return

        await message.answer("üîÑ –ë–æ—Ç –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...")
        logger.info("Bot restart scheduled by admin")

        # Schedule restart
        asyncio.create_task(self.delayed_restart())

    async def delayed_restart(self):
        """Delayed restart with cleanup"""
        if self.parsing_active:
            await self.stop_auto_parsing()

        await asyncio.sleep(5)
        os.execv(sys.executable, ["python"] + sys.argv)

    async def run(self):
        """Start the bot"""
        await self.dp.start_polling(self.bot)


if __name__ == "__main__":
    bot = VacancyBot(TELEGRAM_TOKEN, GROUP_ID_VACANCY, ADMIN_IDS_VACANCY)
    bot.dp.startup.register(on_startup)

    try:
        logger.info("Starting bot...")
        asyncio.run(bot.run())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Bot stopped with error: {e}")
        os.execv(sys.executable, ["python"] + sys.argv)
